// Code generated by mockery v2.15.0. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"

	types "github.com/edgexfoundry/go-mod-secrets/v3/pkg/types"
)

// SecretStoreClient is an autogenerated mock type for the SecretStoreClient type
type SecretStoreClient struct {
	mock.Mock
}

// CheckSecretEngineInstalled provides a mock function with given fields: token, mountPoint, engine
func (_m *SecretStoreClient) CheckSecretEngineInstalled(token string, mountPoint string, engine string) (bool, error) {
	ret := _m.Called(token, mountPoint, engine)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string, string, string) bool); ok {
		r0 = rf(token, mountPoint, engine)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(token, mountPoint, engine)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConfigureConsulAccess provides a mock function with given fields: secretStoreToken, bootstrapACLToken, consulHost, consulPort
func (_m *SecretStoreClient) ConfigureConsulAccess(secretStoreToken string, bootstrapACLToken string, consulHost string, consulPort int) error {
	ret := _m.Called(secretStoreToken, bootstrapACLToken, consulHost, consulPort)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, int) error); ok {
		r0 = rf(secretStoreToken, bootstrapACLToken, consulHost, consulPort)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateRole provides a mock function with given fields: secretStoreToken, consulRole
func (_m *SecretStoreClient) CreateRole(secretStoreToken string, consulRole types.ConsulRole) error {
	ret := _m.Called(secretStoreToken, consulRole)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, types.ConsulRole) error); ok {
		r0 = rf(secretStoreToken, consulRole)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateToken provides a mock function with given fields: token, parameters
func (_m *SecretStoreClient) CreateToken(token string, parameters map[string]interface{}) (map[string]interface{}, error) {
	ret := _m.Called(token, parameters)

	var r0 map[string]interface{}
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}) map[string]interface{}); ok {
		r0 = rf(token, parameters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, map[string]interface{}) error); ok {
		r1 = rf(token, parameters)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableConsulSecretEngine provides a mock function with given fields: token, mountPoint, defaultLeaseTTL
func (_m *SecretStoreClient) EnableConsulSecretEngine(token string, mountPoint string, defaultLeaseTTL string) error {
	ret := _m.Called(token, mountPoint, defaultLeaseTTL)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(token, mountPoint, defaultLeaseTTL)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// EnableKVSecretEngine provides a mock function with given fields: token, mountPoint, kvVersion
func (_m *SecretStoreClient) EnableKVSecretEngine(token string, mountPoint string, kvVersion string) error {
	ret := _m.Called(token, mountPoint, kvVersion)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(token, mountPoint, kvVersion)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// HealthCheck provides a mock function with given fields:
func (_m *SecretStoreClient) HealthCheck() (int, error) {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Init provides a mock function with given fields: secretThreshold, secretShares
func (_m *SecretStoreClient) Init(secretThreshold int, secretShares int) (types.InitResponse, error) {
	ret := _m.Called(secretThreshold, secretShares)

	var r0 types.InitResponse
	if rf, ok := ret.Get(0).(func(int, int) types.InitResponse); ok {
		r0 = rf(secretThreshold, secretShares)
	} else {
		r0 = ret.Get(0).(types.InitResponse)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int, int) error); ok {
		r1 = rf(secretThreshold, secretShares)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstallPolicy provides a mock function with given fields: token, policyName, policyDocument
func (_m *SecretStoreClient) InstallPolicy(token string, policyName string, policyDocument string) error {
	ret := _m.Called(token, policyName, policyDocument)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(token, policyName, policyDocument)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListTokenAccessors provides a mock function with given fields: token
func (_m *SecretStoreClient) ListTokenAccessors(token string) ([]string, error) {
	ret := _m.Called(token)

	var r0 []string
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(token)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LookupToken provides a mock function with given fields: token
func (_m *SecretStoreClient) LookupToken(token string) (types.TokenMetadata, error) {
	ret := _m.Called(token)

	var r0 types.TokenMetadata
	if rf, ok := ret.Get(0).(func(string) types.TokenMetadata); ok {
		r0 = rf(token)
	} else {
		r0 = ret.Get(0).(types.TokenMetadata)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LookupTokenAccessor provides a mock function with given fields: token, accessor
func (_m *SecretStoreClient) LookupTokenAccessor(token string, accessor string) (types.TokenMetadata, error) {
	ret := _m.Called(token, accessor)

	var r0 types.TokenMetadata
	if rf, ok := ret.Get(0).(func(string, string) types.TokenMetadata); ok {
		r0 = rf(token, accessor)
	} else {
		r0 = ret.Get(0).(types.TokenMetadata)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(token, accessor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegenRootToken provides a mock function with given fields: keys
func (_m *SecretStoreClient) RegenRootToken(keys []string) (string, error) {
	ret := _m.Called(keys)

	var r0 string
	if rf, ok := ret.Get(0).(func([]string) string); ok {
		r0 = rf(keys)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]string) error); ok {
		r1 = rf(keys)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RevokeToken provides a mock function with given fields: token
func (_m *SecretStoreClient) RevokeToken(token string) error {
	ret := _m.Called(token)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RevokeTokenAccessor provides a mock function with given fields: token, accessor
func (_m *SecretStoreClient) RevokeTokenAccessor(token string, accessor string) error {
	ret := _m.Called(token, accessor)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(token, accessor)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Unseal provides a mock function with given fields: keysBase64
func (_m *SecretStoreClient) Unseal(keysBase64 []string) error {
	ret := _m.Called(keysBase64)

	var r0 error
	if rf, ok := ret.Get(0).(func([]string) error); ok {
		r0 = rf(keysBase64)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewSecretStoreClient interface {
	mock.TestingT
	Cleanup(func())
}

// NewSecretStoreClient creates a new instance of SecretStoreClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewSecretStoreClient(t mockConstructorTestingTNewSecretStoreClient) *SecretStoreClient {
	mock := &SecretStoreClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
